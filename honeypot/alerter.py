"""
Alert dispatcher — email (SMTP) and webhook (Slack/Teams/Discord).

Both channels are optional and independently enabled via config.yaml.
Alerts are sent asynchronously so they never block the request pipeline.
"""

import logging
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from datetime import datetime
from typing import Optional

import httpx

logger = logging.getLogger("honeypot")

# Colour codes used in Slack / Teams attachment cards
SEVERITY_COLOURS = {
    "INFO":     "#36a64f",   # green
    "MEDIUM":   "#ff9900",   # orange
    "HIGH":     "#e01e1e",   # red
    "CRITICAL": "#7b0000",   # dark red
}


class HoneypotAlerter:
    def __init__(self, config: dict):
        self._email_cfg   = config["alerting"]["email"]
        self._webhook_cfg = config["alerting"]["webhook"]

    # ── Public API ────────────────────────────────────────────────────────────

    async def send_alert(
        self,
        source_ip: str,
        severity: str,
        alert_type: str,
        endpoints: list,
        scanner_type: Optional[str],
        details: str,
    ) -> None:
        ts = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

        if self._email_cfg.get("enabled"):
            try:
                self._send_email(source_ip, severity, alert_type,
                                 endpoints, scanner_type, details, ts)
                logger.info(f"Alert email sent for {source_ip}")
            except Exception as exc:
                logger.error(f"Email alert failed for {source_ip}: {exc}")

        if self._webhook_cfg.get("enabled") and self._webhook_cfg.get("url"):
            try:
                await self._send_webhook(source_ip, severity, alert_type,
                                         endpoints, scanner_type, details, ts)
                logger.info(f"Webhook alert sent for {source_ip}")
            except Exception as exc:
                logger.error(f"Webhook alert failed for {source_ip}: {exc}")

    # ── Email ─────────────────────────────────────────────────────────────────

    def _send_email(
        self,
        source_ip: str,
        severity: str,
        alert_type: str,
        endpoints: list,
        scanner_type: Optional[str],
        details: str,
        timestamp: str,
    ) -> None:
        cfg = self._email_cfg
        msg = MIMEMultipart()
        msg["From"]    = cfg["from_addr"]
        msg["To"]      = cfg["to_addr"]
        msg["Subject"] = f"[HONEYPOT {severity}] {alert_type} — {source_ip}"

        body = self._email_body(
            source_ip, severity, alert_type, endpoints, scanner_type, details, timestamp
        )
        msg.attach(MIMEText(body, "plain", "utf-8"))

        with smtplib.SMTP(cfg["smtp_host"], int(cfg["smtp_port"])) as srv:
            if cfg.get("use_tls"):
                srv.starttls()
            if cfg.get("username"):
                srv.login(cfg["username"], cfg["password"])
            srv.send_message(msg)

    @staticmethod
    def _email_body(
        source_ip: str,
        severity: str,
        alert_type: str,
        endpoints: list,
        scanner_type: Optional[str],
        details: str,
        timestamp: str,
    ) -> str:
        ep_list = "\n".join(f"  • {ep}" for ep in endpoints[:20])
        return f"""\
╔══════════════════════════════════════════════════╗
║           HONEYPOT SECURITY ALERT                ║
╚══════════════════════════════════════════════════╝

Severity      : {severity}
Alert Type    : {alert_type}
Timestamp     : {timestamp}
Source IP     : {source_ip}
Tool/Scanner  : {scanner_type or 'Not detected'}

Endpoints accessed:
{ep_list}

Details:
{details}

──────────────────────────────────────────────────
ACTION REQUIRED
  1. Identify which internal machine owns IP: {source_ip}
     (Check DHCP leases, AD computer accounts, NAC logs)
  2. Isolate the machine from the network immediately.
  3. Begin incident response — assume full compromise.

This alert was generated by the Corporate Honeypot System.
Honeypot node: CORP-INTRANET-OLD01
──────────────────────────────────────────────────
"""

    # ── Webhook (Slack / Teams / Discord) ─────────────────────────────────────

    async def _send_webhook(
        self,
        source_ip: str,
        severity: str,
        alert_type: str,
        endpoints: list,
        scanner_type: Optional[str],
        details: str,
        timestamp: str,
    ) -> None:
        colour  = SEVERITY_COLOURS.get(severity, "#999999")
        ep_text = "\n".join(f"• `{ep}`" for ep in endpoints[:10])

        payload = {
            "text": f":rotating_light: *HONEYPOT ALERT [{severity}]* — {alert_type}",
            "attachments": [
                {
                    "color": colour,
                    "fields": [
                        {"title": "Source IP",       "value": f"`{source_ip}`",               "short": True},
                        {"title": "Severity",        "value": severity,                        "short": True},
                        {"title": "Timestamp",       "value": timestamp,                       "short": True},
                        {"title": "Tool/Scanner",    "value": scanner_type or "Not detected",  "short": True},
                        {"title": "Endpoints Accessed", "value": ep_text or "—",              "short": False},
                        {"title": "Details",         "value": details,                         "short": False},
                        {
                            "title": ":warning: Action Required",
                            "value": (
                                f"Identify owner of internal IP `{source_ip}` via DHCP/AD/NAC. "
                                "Isolate and investigate for compromise."
                            ),
                            "short": False,
                        },
                    ],
                    "footer": "Corporate Honeypot | CORP-INTRANET-OLD01",
                }
            ],
        }

        async with httpx.AsyncClient(timeout=10.0) as client:
            resp = await client.post(self._webhook_cfg["url"], json=payload)
            resp.raise_for_status()
